package monitoring

//se prometheus config docs:
// https://prometheus.io/docs/guides/go-application/

import (
	"encoding/json"
	"fmt"
	"net/http"

	"log"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/team7mysupermon/mySuperMon_Middleware/storage"
)

//declare metric var
var (

	//RUN METRICS :
	SUM_ROWS_AFFECTED_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_ROWS_AFFECTED",
			Help: "Value of the no. of times a row is affected during monitoring",
		})

	SUM_SELECTED_RANGE_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SELECTED_RANGE",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_LOCK_TIME_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_LOCK_TIME",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SORT_ROWS_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SORT_ROWS",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_ERRORS_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_ERRORS",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_ROWS_SENT_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_ROWS_SENT",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SELECT_SCAN_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SELECT_SCAN",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_NO_GOOD_INDEX_USED_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_NO_GOOD_INDEX_USED",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	EXEC_TIME_MAX_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "EXEC_TIME_MAX",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SORT_SCAN_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SUM_SORT_SCAN",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SELECT_RANGE_CHECK_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SELECT_RANGE_CHECK",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_TIMER_WAIT_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_TIMER_WAIT",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	USECASE_IDENTIFIER_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "USECASE_IDENTIFYER",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	START_TIMESTAMP_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "START_TIMESTAMP",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_ROWS_EXAMINED_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_ROWS_EXAMINED",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SELECT_FULL_JOIN_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SELECT_FULL_JOIN",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_NO_INDEX_USED_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_NO_INDEX_USED",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	COUNT_STAR_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "COUNT_STAR",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SELECT_FULL_RANGE_JOIN_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SELECT_FULL_RANGE_JOIN",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SORT_MERGE_PASSES_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SORT_MERGE_PASSES",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	SUM_SORT_RANGE_GAUGE = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "SUM_SORT_RANGE",
			Help: "Value of the no. of selected ranges during monitoring",
		})

	startAutoGenerated storage.StartAutoGenerated
	runAutoGenerated   storage.RunAutoGenerated
	stopAutoGenerated  storage.StopAutoGenerated
)

// registers metrics to expose
func registerMetrics() {
	prometheus.MustRegister(SUM_ROWS_AFFECTED_GAUGE)
	prometheus.MustRegister(SUM_SELECTED_RANGE_GAUGE)
	prometheus.MustRegister(SUM_LOCK_TIME_GAUGE)
	prometheus.MustRegister(SUM_SORT_ROWS_GAUGE)
	prometheus.MustRegister(SUM_ERRORS_GAUGE)
	prometheus.MustRegister(SUM_ROWS_SENT_GAUGE)
	prometheus.MustRegister(SUM_SELECT_SCAN_GAUGE)
	prometheus.MustRegister(SUM_NO_GOOD_INDEX_USED_GAUGE)
	prometheus.MustRegister(EXEC_TIME_MAX_GAUGE)
	prometheus.MustRegister(SUM_SORT_SCAN_GAUGE)
	prometheus.MustRegister(SUM_SELECT_RANGE_CHECK_GAUGE)
	prometheus.MustRegister(SUM_TIMER_WAIT_GAUGE)
	prometheus.MustRegister(SUM_LOCK_TIME_GAUGE)
	prometheus.MustRegister(USECASE_IDENTIFIER_GAUGE)
	prometheus.MustRegister(START_TIMESTAMP_GAUGE)
	prometheus.MustRegister(SUM_ROWS_EXAMINED_GAUGE)
	prometheus.MustRegister(SUM_SELECT_FULL_JOIN_GAUGE)
	prometheus.MustRegister(SUM_NO_INDEX_USED_GAUGE)
	prometheus.MustRegister(COUNT_STAR_GAUGE)
	prometheus.MustRegister(SUM_SELECT_FULL_RANGE_JOIN_GAUGE)
	prometheus.MustRegister(SUM_SORT_MERGE_PASSES_GAUGE)
	prometheus.MustRegister(SUM_SORT_RANGE_GAUGE)
}

func runRecordMetrics() {

	

	go func() {
		for {
			data := runAutoGenerated.RunMetaData.RunSituationResult[0].RunData
			
			SUM_ROWS_AFFECTED_GAUGE.Set(float64(data.SumRowsAffected))
			SUM_SELECTED_RANGE_GAUGE.Set(float64(data.SumSelectRange))
			SUM_LOCK_TIME_GAUGE.Set(data.SumLockTime)
			SUM_SORT_ROWS_GAUGE.Set(float64(data.SumSortRows))
			SUM_ERRORS_GAUGE.Set(float64(data.SumErrors))
			SUM_ROWS_SENT_GAUGE.Set(float64(data.SumSelectScan))
			SUM_SELECT_SCAN_GAUGE.Set(float64(data.SumSelectScan))
			SUM_NO_GOOD_INDEX_USED_GAUGE.Set(float64(data.SumNoGoodIndexUsed))
			//EXEC_TIME_MAX_GAUGE.Set(data.ExecTimeMax)
			SUM_SORT_SCAN_GAUGE.Set(float64(data.SumSortScan))
			SUM_SELECT_RANGE_CHECK_GAUGE.Set(float64(data.SumSelectRangeCheck))
			SUM_TIMER_WAIT_GAUGE.Set(data.SumTimerWait)
			//USECASE_IDENTIFIER_GAUGE.Set(data.UsecaseIdentifier)
			//START_TIMESTAMP_GAUGE.Set(data.Starttimestmap)
			SUM_ROWS_EXAMINED_GAUGE.Set(float64(data.SumRowsAffected))
			SUM_SELECT_FULL_JOIN_GAUGE.Set(float64(data.SumSelectFullJoin))
			SUM_NO_INDEX_USED_GAUGE.Set(float64(data.SumNoIndexUsed))
			COUNT_STAR_GAUGE.Set(float64(data.CountStar))
			SUM_SELECT_FULL_RANGE_JOIN_GAUGE.Set(float64(data.SumSelectFullRangeJoin))
			SUM_SORT_MERGE_PASSES_GAUGE.Set(float64(data.SumSortMergePasses))
			SUM_SORT_RANGE_GAUGE.Set(float64(data.SumSortRange))

			//THE FOLLOWING IS USED FOR TESTING THAT THE METRICS OBSERVES CHANGES
			/* a = a+1
			b = b+2
			SUM_ROWS_AFFECTED_GAUGE.Set(float64(a))
			SUM_SELECTED_RANGE_GAUGE.Set(float64(b)) */
			time.Sleep(5 * time.Second)
		}
	}()

}

func Monitor() {
	registerMetrics()

	http.Handle("/metrics", promhttp.Handler())
	err := http.ListenAndServe(":9090", nil)
	if err != nil {
		return
	}

	log.Fatal(http.ListenAndServe(":9090", nil))

}

func ParseBody(body []byte, action string) {

	fmt.Println(string(body))

	if action == "start" {

		err := json.Unmarshal(body, &startAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}

		fmt.Printf("%+v\n", startAutoGenerated)
	}

	if action == "run" {
		err := json.Unmarshal(body, &runAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}
		runRecordMetrics()
		fmt.Printf("%+v\n", runAutoGenerated)
	}

	if action == "stop" {
		err := json.Unmarshal(body, &stopAutoGenerated)
		if err != nil {
			log.Panicln(err)
		}

		fmt.Printf("%+v\n", stopAutoGenerated)
	}

}

/* func newHandlerWithHistogram(handler http.Handler, histogram *prometheus.HistogramVec) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		start := time.Now()
		status := http.StatusOK

		defer func() {
			histogram.WithLabelValues(fmt.Sprintf("%d", status)).Observe(time.Since(start).Seconds())
		}()

		if req.Method == http.MethodGet {
			handler.ServeHTTP(w, req)
			return
		}
		status = http.StatusBadRequest

		w.WriteHeader(status)
	})
} */
